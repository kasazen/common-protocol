--- FILE: src/core/ManagerWithMerkleVerification.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Auth, Authority} from "solmate/auth/Auth.sol";
import {MerkleProofLib} from "solmate/utils/MerkleProofLib.sol";
import {BoringVault} from "../base/BoringVault.sol";

contract ManagerWithMerkleVerification is Auth {
    BoringVault public immutable vault;
    bytes32 public manageRoot;
    
    event ManageRootUpdated(bytes32 oldRoot, bytes32 newRoot);
    error Manager__InvalidProof();

    constructor(address _owner, address _vault) Auth(_owner, Authority(address(0))) {
        vault = BoringVault(payable(_vault));
    }

    function setManageRoot(bytes32 _manageRoot) external requiresAuth {
        emit ManageRootUpdated(manageRoot, _manageRoot);
        manageRoot = _manageRoot;
    }

    function manageVaultWithMerkleVerification(
        bytes32[][] calldata proofs,
        address[] calldata decodersAndSanitizers,
        address[] calldata targets,
        bytes[] calldata data,
        uint256[] calldata values
    ) external requiresAuth {
        for (uint256 i = 0; i < targets.length; i++) {
            bytes32 leaf = keccak256(abi.encodePacked(decodersAndSanitizers[i], targets[i], data[i]));
            if (!MerkleProofLib.verify(proofs[i], manageRoot, leaf)) revert Manager__InvalidProof();
            vault.manage(targets[i], data[i], values[i]);
        }
    }
}
-e 


--- FILE: src/core/AccountantWithRateProviders.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "solmate/tokens/ERC20.sol";
import {Auth, Authority} from "solmate/auth/Auth.sol";
import "../hooks/WorldIDHook.sol";

contract AccountantWithRateProviders is Auth {
    ERC20 public immutable BASE_ASSET;
    WorldIDHook public immutable HOOK;
    
    uint256 public lastRate = 1e18;
    uint256 public performanceFeeBps = 2500;
    address public feeRecipient;
    address public teller;
    bool public isPaused;

    // Veda Strategy Allocation (e.g., Aave = 0x..., Allocation = 7000 for 70%)
    mapping(address => uint256) public strategyAllocation;
    mapping(address => uint256) public strategyAPY; // Gross APY per strategy in BPS
    
    // Veda Fuel (Points)
    mapping(address => uint256) public points;
    mapping(address => uint256) public lastInteraction;
    mapping(address => uint256) public loyaltyStart;

    event VedaPerformance(uint256 grossYield, uint256 vedaFee, uint256 netUserYield);

    constructor(address _owner, address _asset, address _hook, address _recipient) 
        Auth(_owner, Authority(address(0))) 
    {
        BASE_ASSET = ERC20(_asset);
        HOOK = WorldIDHook(_hook);
        feeRecipient = _recipient;
    }

    function setTeller(address _teller) external requiresAuth { teller = _teller; }
    
    function updateStrategy(address strategy, uint256 allocation, uint256 apy) external requiresAuth {
        strategyAllocation[strategy] = allocation;
        strategyAPY[strategy] = apy;
    }

    function calculateGrossAPY() public view returns (uint256) {
        // Weighted average calculation for the UI
        return 850; // Mock 8.5% for now, logic to loop through strategies
    }

    function recordInteraction(address user) external {
        require(msg.sender == address(HOOK) || msg.sender == teller || msg.sender == owner, "UNAUTHORIZED");
        lastInteraction[user] = block.timestamp;
        if (loyaltyStart[user] == 0) loyaltyStart[user] = block.timestamp;
        points[user] += 10 ether; 
    }

    function updateRate(uint256 newRate) external requiresAuth {
        uint256 fee = 0;
        if (newRate > lastRate) {
            uint256 profit = newRate - lastRate;
            fee = (profit * performanceFeeBps) / 10000;
            newRate = newRate - fee;
        }
        lastRate = newRate;
        emit VedaPerformance(newRate + fee, fee, newRate);
    }

    function togglePause() external requiresAuth { isPaused = !isPaused; }
}
-e 


--- FILE: src/core/VedaArcticLens.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./AccountantWithRateProviders.sol";
import "./TellerWithMultiAssetSupport.sol";
import "../base/BoringVault.sol";

contract VedaArcticLens {
    struct UserDashboard {
        uint256 walletBalance;
        uint256 vaultValueUSD;
        uint256 totalTVL;
        uint256 grossAPY;
        uint256 netAPY;
        uint256 fuelPoints;
        bool isVerified;
        uint256 lockCountdown;
    }

    function getDashboard(address user, address vault, address accountant, address teller) 
        external view returns (UserDashboard memory d) 
    {
        BoringVault v = BoringVault(payable(vault));
        AccountantWithRateProviders acc = AccountantWithRateProviders(accountant);
        TellerWithMultiAssetSupport tel = TellerWithMultiAssetSupport(teller);

        d.walletBalance = v.asset().balanceOf(user);
        d.vaultValueUSD = v.convertToAssets(v.balanceOf(user));
        d.totalTVL = v.asset().balanceOf(address(v)); // Simplified TVL
        d.grossAPY = acc.calculateGrossAPY();
        d.netAPY = acc.getRateTiered(user);
        d.fuelPoints = acc.points(user);
        d.isVerified = acc.HOOK().isVerified(user);
        
        uint256 unlock = tel.depositTimestamp(user) + tel.SHARE_LOCK_PERIOD();
        d.lockCountdown = block.timestamp >= unlock ? 0 : unlock - block.timestamp;
    }
}
-e 


--- FILE: src/core/RevenueSplitter.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "solmate/tokens/ERC20.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";

contract RevenueSplitter {
    using SafeTransferLib for ERC20;

    address public immutable PARTNER_MAIN;
    address public immutable PARTNER_TEST;
    
    constructor(address _main, address _test) {
        PARTNER_MAIN = _main;
        PARTNER_TEST = _test;
    }

    function claimFees(ERC20 asset) external {
        uint256 balance = asset.balanceOf(address(this));
        uint256 half = balance / 2;
        asset.safeTransfer(PARTNER_MAIN, half);
        asset.safeTransfer(PARTNER_TEST, asset.balanceOf(address(this)));
    }
}
-e 


--- FILE: src/core/TellerWithMultiAssetSupport.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "solmate/tokens/ERC20.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";
import {Auth, Authority} from "solmate/auth/Auth.sol";
import "../base/BoringVault.sol";
import "./AccountantWithRateProviders.sol";

contract TellerWithMultiAssetSupport is Auth {
    using SafeTransferLib for ERC20;
    BoringVault public immutable VAULT;
    AccountantWithRateProviders public immutable ACCOUNTANT;
    
    mapping(address => uint256) public depositTimestamp;
    uint256 public constant SHARE_LOCK_PERIOD = 1 days;

    struct HumanStatus {
        bool isVerified;
        bool gasSubsidyActive;
        uint256 currentYieldBoost;
    }

    constructor(address _owner, address _vault, address _accountant) 
        Auth(_owner, Authority(address(0))) 
    {
        VAULT = BoringVault(payable(_vault));
        ACCOUNTANT = AccountantWithRateProviders(_accountant);
    }

    function getHumanStatus(address user) public view returns (HumanStatus memory) {
        bool verified = ACCOUNTANT.HOOK().isVerified(user);
        return HumanStatus(verified, verified, verified ? 2000 : 0);
    }

    function deposit(ERC20 asset, uint256 amount) external returns (uint256 shares) {
        if (!ACCOUNTANT.HOOK().isVerified(msg.sender)) revert("NotHuman");
        asset.safeTransferFrom(msg.sender, address(VAULT), amount);
        shares = amount; 
        VAULT.enter(msg.sender, asset, amount, msg.sender, shares);
        depositTimestamp[msg.sender] = block.timestamp;
        ACCOUNTANT.recordInteraction(msg.sender);
    }

    function ping() external { ACCOUNTANT.recordInteraction(msg.sender); }
}
-e 


--- FILE: src/hooks/WorldIDHook.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract WorldIDHook {
    mapping(address => bool) public verifiedHumans;

    function beforeDeposit(address user, uint256 amount) external {
        // In production, this checks the WorldID Router
    }

    function isVerified(address user) external view returns (bool) {
        return verifiedHumans[user];
    }

    function setVerified(address user, bool status) external {
        // For testing/internal admin use
        verifiedHumans[user] = status;
    }
}
-e 


--- FILE: src/decoders/AcrossV3Decoder.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
interface IAcrossSpokePool {
    function deposit(address recipient, address originToken, uint256 amount, uint256 destinationChainId, uint64 relayerFeePct, uint32 quoteTimestamp, bytes memory message, uint256 maxSamples) external;
}
contract AcrossV3Decoder {
    address public constant SPOKE_POOL = 0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64;
    address public immutable vault;
    uint32 public constant QUOTE_BUFFER = 1 hours;
    constructor(address _vault) { vault = _vault; }
    function verify(address target, bytes calldata data) external view {
        require(target == SPOKE_POOL, "Invalid Target");
        if (bytes4(data[:4]) == IAcrossSpokePool.deposit.selector) {
            address recipient = abi.decode(data[4:36], (address));
            require(recipient == vault, "Invalid Recipient");
            uint32 quoteTimestamp = abi.decode(data[164:196], (uint32));
            require(block.timestamp <= quoteTimestamp + QUOTE_BUFFER, "Quote Expired");
        }
    }
}
-e 


--- FILE: src/decoders/AaveV3Decoder.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IAavePool {
    function setUserEMode(uint8 categoryId) external;
}

contract AaveV3Decoder {
    address public constant POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    function verify(address target, bytes calldata data) external view {
        require(target == POOL, "InvalidTarget");
        if (bytes4(data[:4]) == IAavePool.setUserEMode.selector) {
            uint8 categoryId = abi.decode(data[4:], (uint8));
            require(categoryId == 1, "MustUseStableEMode"); // Maximize capital efficiency
        }
    }
}
-e 


--- FILE: src/decoders/CanonicalBridgeDecoder.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IL2StandardBridge {
    function withdraw(address l2Token, uint256 amount, uint32 minGasLimit, bytes calldata extraData) external;
}

contract CanonicalBridgeDecoder {
    address public constant BRIDGE = 0x4200000000000000000000000000000000000010;
    address public immutable vault;

    error BridgeDecoder__InvalidTarget();

    constructor(address _vault) {
        vault = _vault;
    }

    function verify(address target, bytes calldata data) external view {
        if (target != BRIDGE) revert BridgeDecoder__InvalidTarget();
        // Standard Bridge withdraw logic is simple, but we ensure it is called by the Vault
    }
}
-e 


--- FILE: src/decoders/UniswapDecoder.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract UniswapDecoder {
    function exactInput(
        bytes memory path,
        address recipient,
        uint256 amountIn,
        uint256 amountOutMinimum
    ) external pure returns (bytes memory) {
        return abi.encode(path, recipient, amountIn, amountOutMinimum);
    }
}
-e 


--- FILE: src/base/WorldChainConstants.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

library WorldChainConstants {
    // Verified Infrastructure
    address internal constant NATIVE_USDC = 0x79A02482A880bCE3F13e09Da970dC34db4CD24d1;
    address internal constant WETH = 0x4200000000000000000000000000000000000006;
    address internal constant UNISWAP_ROUTER = 0x091AD9e2e6e5eD44c1c66dB50e49A601F9f36cF6;
    address internal constant UNISWAP_FACTORY = 0x7a5028BDa40e7B173C278C5342087826455ea25a;
    
    // Veda Safety Constants
    uint256 internal constant ONE_BPS = 0.0001e18;
    uint256 internal constant MAX_DEVIATION = 0.001e18;
}
-e 


--- FILE: src/base/BoringVault.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "solmate/tokens/ERC20.sol";
import {Auth, Authority} from "solmate/auth/Auth.sol";
import {ERC4626} from "solmate/tokens/ERC4626.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";

contract BoringVault is ERC4626, Auth {
    using SafeTransferLib for ERC20;

    address public manager;
    error BoringVault__OnlyManager();

    constructor(address _owner, string memory _name, string memory _symbol, ERC20 _asset) 
        ERC4626(_asset, _name, _symbol) 
        Auth(_owner, Authority(address(0))) 
    {}

    function manage(address target, bytes calldata data, uint256 value) external returns (bytes memory) {
        if (msg.sender != manager) revert BoringVault__OnlyManager();
        (bool success, bytes memory returnData) = target.call{value: value}(data);
        require(success, "BoringVault: Call Failed");
        return returnData;
    }

    function setManager(address _manager) external requiresAuth {
        manager = _manager;
    }

    function enter(address, ERC20, uint256, address to, uint256 shares) external requiresAuth {
        _mint(to, shares);
    }

    function exit(address to, ERC20 _asset, uint256 amount, address from, uint256 shares) external requiresAuth {
        _burn(from, shares);
        _asset.safeTransfer(to, amount);
    }

    function totalAssets() public view override returns (uint256) {
        return asset.balanceOf(address(this));
    }
}
-e 


--- FILE: script/BlockMaliciousTx.s.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/base/BoringVault.sol";
import "../src/core/ManagerWithMerkleVerification.sol";
import "../src/decoders/UniswapDecoder.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

contract BlockMaliciousTx is Script {
    function run() external {
        vm.startBroadcast();
        
        // 1. SETUP
        MockERC20 usdc = new MockERC20("USDC", "USDC", 6);
        BoringVault vault = new BoringVault(msg.sender, "Veda Yield", "vWY", usdc);
        ManagerWithMerkleVerification manager = new ManagerWithMerkleVerification(msg.sender, address(vault));
        UniswapDecoder decoder = new UniswapDecoder();
        
        vault.setManager(address(manager));
        usdc.mint(address(vault), 1000e6);
        // 2. AUTHORIZE "GOOD" TRANSACTION (Swap for WETH)
        address goodTarget = 0x091AD9e2e6e5eD44c1c66dB50e49A601F9f36cF6; 
        bytes memory goodData = abi.encode(address(usdc), uint256(100)); 
        
        // The Root is set based on this GOOD data
        bytes32 leaf = keccak256(abi.encodePacked(address(decoder), goodTarget, goodData));
        manager.setManageRoot(leaf);
        console.log("Manager Authorized: GOOD Tx Only");
        // 3. ATTEMPT "BAD" TRANSACTION (Changing the data payload)
        bytes memory badData = abi.encode(address(usdc), uint256(999999)); 

        // Prepare the arrays for the Malicious Call
        bytes32[][] memory proofs = new bytes32[][](1); 
        address[] memory decoders = new address[](1);
        decoders[0] = address(decoder);
        address[] memory targets = new address[](1);
        targets[0] = goodTarget;
        
        bytes[] memory datas = new bytes[](1);
        datas[0] = badData; // <--- THE MALICIOUS PAYLOAD
        
        uint256[] memory values = new uint256[](1);

        console.log("Attempting Malicious Execution...");

        // 4. VERIFY REJECTION
        try manager.manageVaultWithMerkleVerification(proofs, decoders, targets, datas, values) {
            console.log("CRITICAL FAILURE: Malicious Tx was ALLOWED!");
        } catch {
            console.log("SUCCESS: Tx Blocked (Invalid Proof).");
        }

        vm.stopBroadcast();
    }
}
-e 


--- FILE: script/SimulateVedaState.s.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/base/BoringVault.sol";
import "../src/core/ManagerWithMerkleVerification.sol";
import "../src/core/TellerWithMultiAssetSupport.sol";
import "../src/core/AccountantWithRateProviders.sol";
import "../src/core/RevenueSplitter.sol";
import "../src/hooks/WorldIDHook.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

contract SimulateVedaState is Script {
    function run() external {
        vm.startBroadcast();
        
        MockERC20 usdc = new MockERC20("USDC", "USDC", 6);
        WorldIDHook hook = new WorldIDHook();
        RevenueSplitter splitter = new RevenueSplitter(msg.sender, address(0x123)); 
        
        // Match 4 arguments: Owner, Asset, Hook, Splitter
        AccountantWithRateProviders accountant = new AccountantWithRateProviders(
            msg.sender, 
            address(usdc), 
            address(hook), 
            address(splitter)
        );
        
        BoringVault vault = new BoringVault(payable(msg.sender), "Veda", "vWY", usdc);
        ManagerWithMerkleVerification manager = new ManagerWithMerkleVerification(msg.sender, address(vault));
        TellerWithMultiAssetSupport teller = new TellerWithMultiAssetSupport(msg.sender, address(vault), address(accountant));

        accountant.setTeller(address(teller));
        vault.setManager(address(manager)); 
        
        vm.stopBroadcast();
    }
}
-e 


--- FILE: script/ExecuteStrategy.s.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/base/BoringVault.sol";
import "../src/core/ManagerWithMerkleVerification.sol";
import "../src/core/TellerWithMultiAssetSupport.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";
import "../src/decoders/UniswapDecoder.sol"; // We need the decoder we made earlier

contract ExecuteStrategy is Script {
    function run() external {
        vm.startBroadcast();
        
        // 1. SETUP (Re-deploying for self-contained sim)
        MockERC20 usdc = new MockERC20("USDC", "USDC", 6);
        BoringVault vault = new BoringVault(msg.sender, "Veda Yield", "vWY", usdc);
        ManagerWithMerkleVerification manager = new ManagerWithMerkleVerification(msg.sender, address(vault));
        UniswapDecoder decoder = new UniswapDecoder();

        // Wire it
        vault.setManager(address(manager));
        
        // Fund the Vault (Simulate a user deposit)
        usdc.mint(address(vault), 1000e6); 
        console.log("Vault Funded with 1000 USDC");
        // 2. DEFINE THE STRATEGY (Swap 100 USDC -> WETH)
        address target = 0x091AD9e2e6e5eD44c1c66dB50e49A601F9f36cF6; // Uniswap Router
        bytes memory swapData = abi.encodeWithSelector(
            0x414bf389, // exactInput selector
            abi.encodePacked(address(usdc), uint24(500), address(0x4200000000000000000000000000000000000006)), // Path
            address(vault), // Recipient (Must be Vault)
            uint256(100e6), // AmountIn
            uint256(0)      // MinAmountOut
        );

        // 3. GENERATE MERKLE LEAF
        // Leaf = Keccak256(Decoder + Target + Data)
        bytes32 leaf = keccak256(abi.encodePacked(address(decoder), target, swapData));
        
        // For a single-item tree, the Root IS the Leaf.
        bytes32 root = leaf;

        // 4. AUTHORIZE STRATEGY
        manager.setManageRoot(root);
        console.log("Manager Root Updated");

        // 5. EXECUTE
        // We prepare the arrays for the Manager call
        bytes32[][] memory proofs = new bytes32[][](1); // Empty proof for single leaf
        address[] memory decoders = new address[](1);
        decoders[0] = address(decoder);
        address[] memory targets = new address[](1);
        targets[0] = target;
        bytes[] memory datas = new bytes[](1);
        datas[0] = swapData;
        uint256[] memory values = new uint256[](1);
        values[0] = 0;

        console.log("Attempting Execution...");
        // This will FAIL strictly because we are mocking and Uniswap doesnt exist on localhost.
        // But if it reaches the "Call Failed" revert in BoringVault, we know the Manager passed!
        try manager.manageVaultWithMerkleVerification(proofs, decoders, targets, datas, values) {
            console.log("SUCCESS: Manager approved execution!");
        } catch Error(string memory reason) {
            console.log("REVERTED (Expected on Mock):", reason);
        }

        vm.stopBroadcast();
    }
}
-e 


--- FILE: script/DeployVedaArctic.s.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/base/BoringVault.sol";
import "../src/core/ManagerWithMerkleVerification.sol";
import "../src/core/TellerWithMultiAssetSupport.sol";
import "../src/core/AccountantWithRateProviders.sol";
import "../src/core/RevenueSplitter.sol";
import "../src/core/VedaArcticLens.sol";
import "../src/hooks/WorldIDHook.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";

contract DeployVedaArctic is Script {
    function run() external {
        // --- WORLD CHAIN MAINNET CONSTANTS ---
        address USDC = 0x79A02482A880bCE3F13e09Da970dC34db4CD24d1; 
        address AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
        
        // Splitter Config: Main Wallet & Test Wallet
        address mainWallet = msg.sender;
        address testWallet = 0x...; // PASTE YOUR TEST WALLET HERE

        vm.startBroadcast();

        // 1. Infrastructure
        WorldIDHook hook = new WorldIDHook(); 
        RevenueSplitter splitter = new RevenueSplitter(mainWallet, testWallet);
        VedaArcticLens lens = new VedaArcticLens();

        // 2. Core Protocol
        AccountantWithRateProviders accountant = new AccountantWithRateProviders(
            mainWallet, USDC, address(hook), address(splitter)
        );

        BoringVault vault = new BoringVault(mainWallet, "Veda Arctic USDC", "vUSDC", ERC20(USDC));
        
        ManagerWithMerkleVerification manager = new ManagerWithMerkleVerification(
            mainWallet, address(vault)
        );

        TellerWithMultiAssetSupport teller = new TellerWithMultiAssetSupport(
            mainWallet, address(vault), address(accountant)
        );

        // 3. The "Veda Protocol" Wiring
        accountant.setTeller(address(teller));
        vault.setManager(address(manager));
        
        // Set initial Strategy APY (Example: Aave V3 at 4.5% Gross)
        accountant.updateStrategy(AAVE_POOL, 10000, 450);

        vm.stopBroadcast();
        
        console.log("----------------------------");
        console.log("VEDA ARCTIC DEPLOYED");
        console.log("Vault: ", address(vault));
        console.log("Accountant: ", address(accountant));
        console.log("Teller (User Gate): ", address(teller));
        console.log("Lens (UI Entry): ", address(lens));
        console.log("Splitter (Revenue): ", address(splitter));
        console.log("----------------------------");
    }
}
-e 


--- FILE: script/EmergencyExit.s.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/core/AccountantWithRateProviders.sol";

contract EmergencyExit is Script {
    function run(address accountantAddr) external {
        vm.startBroadcast();
        // Fixed: Ensure we call the correct function on the Accountant
        AccountantWithRateProviders(accountantAddr).togglePause();
        console.log("SYSTEM PAUSED - EMERGENCY EXIT INITIATED");
        vm.stopBroadcast();
    }
}
-e 


--- FILE: test/WorldIDYieldSim.t.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
import "forge-std/Test.sol";
import "../src/core/AccountantWithRateProviders.sol";
import "../src/core/TellerWithMultiAssetSupport.sol";
import "../src/hooks/WorldIDHook.sol";
import "../src/base/BoringVault.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

contract WorldIDYieldSim is Test {
    BoringVault vault;
    AccountantWithRateProviders accountant;
    TellerWithMultiAssetSupport teller;
    WorldIDHook hook;
    MockERC20 usdc;

    address human = address(0x111);

    function setUp() public {
        usdc = new MockERC20("USDC", "USDC", 6);
        hook = new WorldIDHook();
        vault = new BoringVault(address(this), "Veda", "vWY", usdc);
        accountant = new AccountantWithRateProviders(address(this), address(usdc), address(hook), address(0xFEED));
        teller = new TellerWithMultiAssetSupport(address(this), address(vault), address(accountant));

        // CRITICAL: Authorize the teller
        accountant.setTeller(address(teller));
        
        vault.setManager(address(this));
        hook.setVerified(human, true);
    }

    function test_FuelAccrualOnPing() public {
        vm.startPrank(human);
        uint256 pointsBefore = accountant.points(human);
        teller.ping();
        uint256 pointsAfter = accountant.points(human);
        
        assertGt(pointsAfter, pointsBefore, "Fuel tank should fill up");
        vm.stopPrank();
    }
}
-e 


--- FILE: test/VedaArctic.t.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/base/BoringVault.sol";
import "../src/core/ManagerWithMerkleVerification.sol";
import "../src/core/TellerWithMultiAssetSupport.sol";
import "../src/core/AccountantWithRateProviders.sol";
import "../src/hooks/WorldIDHook.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

contract VedaArcticTest is Test {
    BoringVault vault;
    AccountantWithRateProviders accountant;
    TellerWithMultiAssetSupport teller;
    WorldIDHook hook;
    MockERC20 usdc;

    address user = address(0xABCD);

    function setUp() public {
        usdc = new MockERC20("USDC", "USDC", 6);
        hook = new WorldIDHook();
        accountant = new AccountantWithRateProviders(address(this), address(usdc), address(hook), address(0x1));
        vault = new BoringVault(address(this), "Veda Yield", "vWY", usdc);
        teller = new TellerWithMultiAssetSupport(address(this), address(vault), address(accountant));

        vault.setManager(address(this));
        hook.setVerified(user, true);
        usdc.mint(user, 1000e6);
    }

    function test_UserDeposit_HappyPath() public {
        vm.startPrank(user);
        usdc.approve(address(teller), 1000e6);
        uint256 shares = teller.deposit(usdc, 1000e6);
        assertEq(shares, 1000e6);
        vm.stopPrank();
    }
}
-e 


--- FILE: test/FeeCollectionSim.t.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/core/AccountantWithRateProviders.sol";
import "../src/hooks/WorldIDHook.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

contract FeeCollectionSim is Test {
    AccountantWithRateProviders accountant;
    WorldIDHook hook;
    MockERC20 usdc;
    address feeSplitter = address(0xFEED);

    function setUp() public {
        usdc = new MockERC20("USDC", "USDC", 6);
        hook = new WorldIDHook();
        accountant = new AccountantWithRateProviders(
            address(this), 
            address(usdc), 
            address(hook), 
            feeSplitter
        );
    }

    function test_PerformanceFeeLogic() public {
        uint256 grossNewRate = 1.0008e18; 
        accountant.updateRate(grossNewRate);
        assertEq(accountant.lastRate(), 1.0006e18);
    }
}
-e 


