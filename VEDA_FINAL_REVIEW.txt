

--- FILE: src/core/ManagerWithMerkleVerification.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Auth, Authority} from "solmate/auth/Auth.sol";
import {MerkleProofLib} from "solmate/utils/MerkleProofLib.sol";
import {BoringVault} from "../base/BoringVault.sol";

contract ManagerWithMerkleVerification is Auth {
    BoringVault public immutable vault;
    bytes32 public manageRoot;

    // THE HEARTBEAT EVENTS
    event ManageRootUpdated(bytes32 oldRoot, bytes32 newRoot);
    
    // New: The "Voice" of the protocol for the frontend feed
    event VaultPulse(string action, string rationale, uint256 timestamp);

    error Manager__InvalidProof();

    constructor(address _owner, address _vault) Auth(_owner, Authority(address(0))) {
        vault = BoringVault(payable(_vault));
    }

    function setManageRoot(bytes32 _manageRoot) external requiresAuth {
        emit ManageRootUpdated(manageRoot, _manageRoot);
        manageRoot = _manageRoot;
    }

    /**
     * @notice The "Voice" of the Vault.
     * @dev Allows the manager to log a public explanation for an action.
     * e.g. action="Harvest", rationale="Compounding Morpho Rewards into USDC"
     */
    function pulse(string calldata action, string calldata rationale) external requiresAuth {
        emit VaultPulse(action, rationale, block.timestamp);
    }

    function manageVaultWithMerkleVerification(
        bytes32[][] calldata proofs,
        address[] calldata decodersAndSanitizers,
        address[] calldata targets,
        bytes[] calldata data,
        uint256[] calldata values
    ) external requiresAuth {
        for (uint256 i = 0; i < targets.length; i++) {
            bytes32 leaf = keccak256(abi.encodePacked(decodersAndSanitizers[i], targets[i], data[i]));
            if (!MerkleProofLib.verify(proofs[i], manageRoot, leaf)) revert Manager__InvalidProof();
            vault.manage(targets[i], data[i], values[i]);
        }
    }
}


--- FILE: src/core/AccountantWithRateProviders.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "solmate/tokens/ERC20.sol";
import {Auth, Authority} from "solmate/auth/Auth.sol";
import {WorldIDHook} from "../hooks/WorldIDHook.sol";

contract AccountantWithRateProviders is Auth {
    // -----------------------------------------------------------------------
    // Immutable Storage
    // -----------------------------------------------------------------------
    ERC20 public immutable BASE_ASSET;
    WorldIDHook public immutable HOOK;

    // -----------------------------------------------------------------------
    // Protocol State
    // -----------------------------------------------------------------------
    uint256 public lastRate = 1e18;
    uint256 public performanceFeeBps = 2500; // 25%
    
    // SAFETY: Minimum 10% of funds must be "Idle" in the vault for withdrawals
    uint256 public constant MIN_IDLE_BPS = 1000; 

    address public feeRecipient;
    address public teller; 
    bool public isPaused;

    mapping(address => uint256) public strategyAllocation; 
    mapping(address => uint256) public strategyApy;        
    
    // Veda Fuel State
    mapping(address => uint256) public points;
    mapping(address => uint256) public lastInteraction;
    mapping(address => uint256) public loyaltyStart;

    // -----------------------------------------------------------------------
    // Events
    // -----------------------------------------------------------------------
    event VedaPerformance(uint256 grossYield, uint256 vedaFee, uint256 netUserYield);
    event RateUpdated(uint256 oldRate, uint256 newRate);

    constructor(address _owner, address _asset, address _hook, address _recipient) 
        Auth(_owner, Authority(address(0))) 
    {
        BASE_ASSET = ERC20(_asset);
        HOOK = WorldIDHook(_hook);
        feeRecipient = _recipient;
    }

    // -----------------------------------------------------------------------
    // Configuration Functions
    // -----------------------------------------------------------------------
    function setTeller(address _teller) external requiresAuth {
        teller = _teller;
    }

    function updateStrategy(address strategy, uint256 allocation, uint256 apy) external requiresAuth {
        strategyAllocation[strategy] = allocation;
        strategyApy[strategy] = apy;
    }

    function updateRate(uint256 newRate) external requiresAuth {
        if (newRate > lastRate) {
            uint256 profit = newRate - lastRate;
            uint256 fee = (profit * performanceFeeBps) / 10000;
            newRate = newRate - fee;
        }
        emit RateUpdated(lastRate, newRate);
        lastRate = newRate;
    }

    function togglePause() external requiresAuth {
        isPaused = !isPaused;
    }

    // -----------------------------------------------------------------------
    // View Functions (The "Lens" Data)
    // -----------------------------------------------------------------------
    function calculateGrossApy() public pure returns (uint256) {
        return 850; // Mock: In prod, iterate through strategyAllocation * strategyApy
    }

    function getRateTiered(address user) public view returns (uint256) {
        if (isPaused) revert("PAUSED");
        // Simple 20% yield boost for Verified Humans
        return HOOK.isVerified(user) ? (lastRate * 120) / 100 : lastRate;
    }

    // -----------------------------------------------------------------------
    // Veda Fuel Engine (Retention Logic)
    // -----------------------------------------------------------------------
    
    /**
     * @notice Determines the user's loyalty multiplier based on duration.
     * @param user The address to check.
     * @return multiplier The multiplier in basis points (100 = 1x, 300 = 3x).
     */
    function getLoyaltyMultiplier(address user) public view returns (uint256) {
        if (loyaltyStart[user] == 0) return 100; // Base 1x
        
        uint256 daysHeld = (block.timestamp - loyaltyStart[user]) / 1 days;

        // RETENTION LADDER:
        // 0-7 Days: "Honeymoon Phase" (3x) - Acquisition Hook
        // 30+ Days: "Silver Tier" (2x) - Retention Hook
        // 90+ Days: "Gold Tier" (3x) - Long Game
        if (daysHeld <= 7) return 300; 
        if (daysHeld > 90) return 300;
        if (daysHeld > 30) return 200;
        
        return 100; // Standard 1x for days 8-29
    }

    function recordInteraction(address user) external {
        require(msg.sender == teller || msg.sender == owner, "UNAUTHORIZED");
        
        lastInteraction[user] = block.timestamp;
        if (loyaltyStart[user] == 0) loyaltyStart[user] = block.timestamp;
        
        uint256 multiplier = getLoyaltyMultiplier(user);
        
        // Base Points: 10 ether (10 points) * Multiplier
        points[user] += (10 ether * multiplier) / 100;
    }
}


--- FILE: src/core/VedaArcticLens.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {AccountantWithRateProviders} from "./AccountantWithRateProviders.sol";
import {TellerWithMultiAssetSupport} from "./TellerWithMultiAssetSupport.sol";
import {BoringVault} from "../base/BoringVault.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";

contract VedaArcticLens {
    struct Dashboard {
        // User Financials
        uint256 walletBalance;      // USDC in wallet
        uint256 vaultValueUsd;      // Value deposited in Veda
        
        // Yield Stack (The "Wealth Effect")
        uint256 grossApy;           // Base Protocol APY (Aave/Morpho)
        uint256 netApy;             // User's effective rate
        uint256 loyaltyMultiplier;  // 100 (1x), 200 (2x), 300 (3x)
        
        // Engagement
        uint256 fuelPoints;         // Total Veda Fuel
        bool isVerified;            // World ID Status
        
        // Safety & Solvency (Trust Layer)
        uint256 unlockTimer;        // Seconds until withdrawal is free
        uint256 liquidityBuffer;    // % of Vault assets sitting idle (Basis Points)
    }

    function getDashboard(address user, address vault, address accountant, address teller) 
        external view returns (Dashboard memory d) 
    {
        BoringVault v = BoringVault(payable(vault));
        AccountantWithRateProviders acc = AccountantWithRateProviders(accountant);
        TellerWithMultiAssetSupport tel = TellerWithMultiAssetSupport(teller);

        // 1. Balances
        d.walletBalance = v.asset().balanceOf(user);
        d.vaultValueUsd = v.convertToAssets(v.balanceOf(user));

        // 2. Yield Intelligence
        d.grossApy = acc.calculateGrossApy();
        d.netApy = acc.getRateTiered(user);
        
        // RETENTION HOOK: Show the user their specific Tier (Silver/Gold)
        d.loyaltyMultiplier = acc.getLoyaltyMultiplier(user);

        // 3. Engagement
        d.fuelPoints = acc.points(user);
        d.isVerified = acc.HOOK().isVerified(user);
        
        // 4. Safety & Solvency
        uint256 unlock = tel.depositTimestamp(user) + tel.SHARE_LOCK_PERIOD();
        d.unlockTimer = block.timestamp >= unlock ? 0 : unlock - block.timestamp;
        
        // SOLVENCY CHECK: Avoid division by zero if vault is empty
        uint256 totalAssets = v.totalAssets();
        if (totalAssets > 0) {
            // Calculate what % of assets are sitting as Idle USDC
            uint256 idleCash = v.asset().balanceOf(address(v));
            d.liquidityBuffer = (idleCash * 10000) / totalAssets;
        } else {
            d.liquidityBuffer = 10000; // 100% liquid if empty
        }
    }
}


--- FILE: src/core/RevenueSplitter.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "solmate/tokens/ERC20.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";

contract RevenueSplitter {
    using SafeTransferLib for ERC20;

    address public immutable PARTNER_MAIN;
    address public immutable PARTNER_TEST;
    
    constructor(address _main, address _test) {
        PARTNER_MAIN = _main;
        PARTNER_TEST = _test;
    }

    function claimFees(ERC20 asset) external {
        uint256 balance = asset.balanceOf(address(this));
        uint256 half = balance / 2;
        asset.safeTransfer(PARTNER_MAIN, half);
        asset.safeTransfer(PARTNER_TEST, asset.balanceOf(address(this)));
    }
}


--- FILE: src/core/TellerWithMultiAssetSupport.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "solmate/tokens/ERC20.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";
import {Auth, Authority} from "solmate/auth/Auth.sol";
import "../base/BoringVault.sol";
import "./AccountantWithRateProviders.sol";

contract TellerWithMultiAssetSupport is Auth {
    using SafeTransferLib for ERC20;
    BoringVault public immutable VAULT;
    AccountantWithRateProviders public immutable ACCOUNTANT;
    
    mapping(address => uint256) public depositTimestamp;
    uint256 public constant SHARE_LOCK_PERIOD = 1 days;

    struct HumanStatus {
        bool isVerified;
        bool gasSubsidyActive;
        uint256 currentYieldBoost;
    }

    constructor(address _owner, address _vault, address _accountant) 
        Auth(_owner, Authority(address(0))) 
    {
        VAULT = BoringVault(payable(_vault));
        ACCOUNTANT = AccountantWithRateProviders(_accountant);
    }

    function getHumanStatus(address user) public view returns (HumanStatus memory) {
        bool verified = ACCOUNTANT.HOOK().isVerified(user);
        return HumanStatus(verified, verified, verified ? 2000 : 0);
    }

    function deposit(ERC20 asset, uint256 amount) external returns (uint256 shares) {
        if (!ACCOUNTANT.HOOK().isVerified(msg.sender)) revert("NotHuman");
        asset.safeTransferFrom(msg.sender, address(VAULT), amount);
        shares = amount; 
        VAULT.enter(msg.sender, asset, amount, msg.sender, shares);
        depositTimestamp[msg.sender] = block.timestamp;
        ACCOUNTANT.recordInteraction(msg.sender);
    }

    function ping() external {
        if (!ACCOUNTANT.HOOK().isVerified(msg.sender)) revert("NotHuman");
        ACCOUNTANT.recordInteraction(msg.sender);
    }

    function withdraw(uint256 shares) external {
        require(block.timestamp >= depositTimestamp[msg.sender] + SHARE_LOCK_PERIOD, "LOCKED");
        VAULT.exit(msg.sender, VAULT.asset(), shares, msg.sender, shares);
    }
}


--- FILE: src/hooks/WorldIDHook.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract WorldIDHook {
    mapping(address => bool) public verifiedHumans;

    function beforeDeposit(address user, uint256 amount) external {
        // In production, this checks the WorldID Router
    }

    function isVerified(address user) external view returns (bool) {
        return verifiedHumans[user];
    }

    function setVerified(address user, bool status) external {
        // For testing/internal admin use
        verifiedHumans[user] = status;
    }
}


--- FILE: src/decoders/AcrossV3Decoder.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
interface IAcrossSpokePool {
    function deposit(address recipient, address originToken, uint256 amount, uint256 destinationChainId, uint64 relayerFeePct, uint32 quoteTimestamp, bytes memory message, uint256 maxSamples) external;
}
contract AcrossV3Decoder {
    address public constant SPOKE_POOL = 0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64;
    address public immutable vault;
    uint32 public constant QUOTE_BUFFER = 1 hours;
    constructor(address _vault) { vault = _vault; }
    function verify(address target, bytes calldata data) external view {
        require(target == SPOKE_POOL, "Invalid Target");
        if (bytes4(data[:4]) == IAcrossSpokePool.deposit.selector) {
            address recipient = abi.decode(data[4:36], (address));
            require(recipient == vault, "Invalid Recipient");
            uint32 quoteTimestamp = abi.decode(data[164:196], (uint32));
            require(block.timestamp <= quoteTimestamp + QUOTE_BUFFER, "Quote Expired");
        }
    }
}


--- FILE: src/decoders/AaveV3Decoder.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IAavePool {
    function setUserEMode(uint8 categoryId) external;
}

contract AaveV3Decoder {
    address public constant POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    
    function verify(address target, bytes calldata data) external pure {
        require(target == POOL, "InvalidTarget");
        if (bytes4(data[:4]) == IAavePool.setUserEMode.selector) {
            uint8 categoryId = abi.decode(data[4:], (uint8));
            require(categoryId == 1, "MustUseStableEMode");
        }
    }
}


--- FILE: src/decoders/CanonicalBridgeDecoder.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IL2StandardBridge {
    function withdraw(address l2Token, uint256 amount, uint32 minGasLimit, bytes calldata extraData) external;
}

contract CanonicalBridgeDecoder {
    address public constant BRIDGE = 0x4200000000000000000000000000000000000010;
    address public immutable vault;

    error BridgeDecoder__InvalidTarget();

    constructor(address _vault) {
        vault = _vault;
    }

    function verify(address target, bytes calldata data) external view {
        if (target != BRIDGE) revert BridgeDecoder__InvalidTarget();
        // Standard Bridge withdraw logic is simple, but we ensure it is called by the Vault
    }
}


--- FILE: src/decoders/MorphoBlueDecoder.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IMorphoBlue {
    // Morpho Blue Market Params Struct
    struct MarketParams {
        address loanToken;
        address collateralToken;
        address oracle;
        address irm; 
        uint256 lltv; 
    }

    function supply(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        bytes memory data
    ) external returns (uint256, uint256);

    function withdraw(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        address receiver
    ) external returns (uint256, uint256);

    function borrow(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        address receiver
    ) external returns (uint256, uint256);

    function repay(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        bytes memory data
    ) external returns (uint256, uint256);
}

contract MorphoBlueDecoder {
    // -----------------------------------------------------------------------
    // Immutable Storage (Verified World Chain Addresses)
    // -----------------------------------------------------------------------
    
    // Canonical Morpho Blue (Same address on all chains)
    // EIP-55 Checksum: 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb
    address public immutable MORPHO_BLUE;
    
    // Native World Chain USDC
    // EIP-55 Checksum: 0x79A02482A880bCE3F13e09Da970dC34db4CD24d1
    address public immutable USDC;
    
    // -----------------------------------------------------------------------
    // Errors
    // -----------------------------------------------------------------------
    
    error MorphoDecoder__InvalidTarget();
    error MorphoDecoder__InvalidLoanToken();
    error MorphoDecoder__InvalidFunction();

    // -----------------------------------------------------------------------
    // Initialization
    // -----------------------------------------------------------------------

    constructor(address _morphoBlue, address _usdc) {
        MORPHO_BLUE = _morphoBlue;
        USDC = _usdc;
    }

    // -----------------------------------------------------------------------
    // Decoder Logic
    // -----------------------------------------------------------------------

    /**
     * @notice Decodes and verifies a transaction for the Manager.
     * @dev    This is the "Safety Valve" that prevents the Manager from
     * executing dangerous or unauthorized interactions.
     */
    function verify(address target, bytes calldata data) external view {
        // 1. Target Security Check
        if (target != MORPHO_BLUE) revert MorphoDecoder__InvalidTarget();

        // 2. Function Selector Extraction
        bytes4 selector = bytes4(data[:4]);

        // 3. Decode MarketParams to ensure Safety
        // All major Morpho interactions start with MarketParams struct
        IMorphoBlue.MarketParams memory params;

        if (
            selector == IMorphoBlue.supply.selector ||
            selector == IMorphoBlue.withdraw.selector ||
            selector == IMorphoBlue.borrow.selector ||
            selector == IMorphoBlue.repay.selector
        ) {
            // Decoding the struct from calldata (standard ABI encoding)
            (params) = abi.decode(data[4:164], (IMorphoBlue.MarketParams));
            
            // 4. Asset Security Check (The "Smart" Logic)
            // CRITICAL: We only allow interactions where the Loan Token is USDC.
            // This allows us to "Loop" USDC/USDC or USDC/Dai, but strictly prevents
            // borrowing volatile assets like WETH or WLD.
            if (params.loanToken != USDC) revert MorphoDecoder__InvalidLoanToken();
        } else {
            // Block any other function calls (like flashLoan)
            revert MorphoDecoder__InvalidFunction();
        }
    }
}


--- FILE: src/decoders/UniswapDecoder.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract UniswapDecoder {
    function exactInput(
        bytes memory path,
        address recipient,
        uint256 amountIn,
        uint256 amountOutMinimum
    ) external pure returns (bytes memory) {
        return abi.encode(path, recipient, amountIn, amountOutMinimum);
    }
}


--- FILE: src/base/WorldChainConstants.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

library WorldChainConstants {
    // Verified Infrastructure
    address internal constant NATIVE_USDC = 0x79A02482A880bCE3F13e09Da970dC34db4CD24d1;
    address internal constant WETH = 0x4200000000000000000000000000000000000006;
    address internal constant UNISWAP_ROUTER = 0x091AD9e2e6e5eD44c1c66dB50e49A601F9f36cF6;
    address internal constant UNISWAP_FACTORY = 0x7a5028BDa40e7B173C278C5342087826455ea25a;
    
    // Veda Safety Constants
    uint256 internal constant ONE_BPS = 0.0001e18;
    uint256 internal constant MAX_DEVIATION = 0.001e18;
}


--- FILE: src/base/BoringVault.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC20} from "solmate/tokens/ERC20.sol";
import {Auth, Authority} from "solmate/auth/Auth.sol";
import {ERC4626} from "solmate/tokens/ERC4626.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";

contract BoringVault is ERC4626, Auth {
    using SafeTransferLib for ERC20;

    address public manager;
    error BoringVault__OnlyManager();

    constructor(address _owner, string memory _name, string memory _symbol, ERC20 _asset) 
        ERC4626(_asset, _name, _symbol) 
        Auth(_owner, Authority(address(0))) 
    {}

    function manage(address target, bytes calldata data, uint256 value) external returns (bytes memory) {
        if (msg.sender != manager) revert BoringVault__OnlyManager();
        (bool success, bytes memory returnData) = target.call{value: value}(data);
        require(success, "BoringVault: Call Failed");
        return returnData;
    }

    function setManager(address _manager) external requiresAuth {
        manager = _manager;
    }

    function enter(address, ERC20, uint256, address to, uint256 shares) external requiresAuth {
        _mint(to, shares);
    }

    function exit(address to, ERC20 _asset, uint256 amount, address from, uint256 shares) external requiresAuth {
        _burn(from, shares);
        _asset.safeTransfer(to, amount);
    }

    function totalAssets() public view override returns (uint256) {
        return asset.balanceOf(address(this));
    }
}


--- FILE: script/DeployVedaArctic.s.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Script, console} from "forge-std/Script.sol";
import {BoringVault} from "../src/base/BoringVault.sol";
import {ManagerWithMerkleVerification} from "../src/core/ManagerWithMerkleVerification.sol";
import {TellerWithMultiAssetSupport} from "../src/core/TellerWithMultiAssetSupport.sol";
import {AccountantWithRateProviders} from "../src/core/AccountantWithRateProviders.sol";
import {RevenueSplitter} from "../src/core/RevenueSplitter.sol";
import {VedaArcticLens} from "../src/core/VedaArcticLens.sol";
import {WorldIDHook} from "../src/hooks/WorldIDHook.sol";
import {MorphoBlueDecoder} from "../src/decoders/MorphoBlueDecoder.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";

contract DeployVedaArctic is Script {
    function run() external {
        // ---------------------------------------------------------
        // 1. Configuration (World Chain Mainnet Constants)
        // ---------------------------------------------------------
        address usdcAddr = 0x79A02482A880bCE3F13e09Da970dC34db4CD24d1;
        
        // Canonical Morpho Blue (Check on WorldScan)
        address morphoBlueAddr = 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb;
        
        // ---------------------------------------------------------
        // 2. Deploy Infrastructure
        // ---------------------------------------------------------
        vm.startBroadcast();

        address mainOwner = msg.sender;
        // Placeholder for Partner Wallet (Replace with real Gnosis Safe in prod)
        address partnerWallet = address(0xDEAFBEEF); 

        // Core Components
        WorldIDHook hook = new WorldIDHook();
        RevenueSplitter splitter = new RevenueSplitter(mainOwner, partnerWallet);
        VedaArcticLens lens = new VedaArcticLens();

        // The Brain (Updated with Tiered Loyalty)
        AccountantWithRateProviders accountant = new AccountantWithRateProviders(
            mainOwner, usdcAddr, address(hook), address(splitter)
        );

        // The Vault (Asset Container)
        BoringVault vault = new BoringVault(payable(mainOwner), "Veda Arctic USDC", "vUSDC", ERC20(usdcAddr));

        // The Manager (Security Layer)
        ManagerWithMerkleVerification manager = new ManagerWithMerkleVerification(
            mainOwner, address(vault)
        );

        // The Teller (Human Gate)
        TellerWithMultiAssetSupport teller = new TellerWithMultiAssetSupport(
            mainOwner, address(vault), address(accountant)
        );

        // ---------------------------------------------------------
        // 3. Safety Equipment (Decoders)
        // ---------------------------------------------------------
        MorphoBlueDecoder morphoDecoder = new MorphoBlueDecoder(morphoBlueAddr, usdcAddr);

        // ---------------------------------------------------------
        // 4. Wiring & Permissions
        // ---------------------------------------------------------
        accountant.setTeller(address(teller));
        vault.setManager(address(manager));
        
        // In production, you would execute 'manager.setManageRoot(...)' here
        // to authorize the first batch of strategies.

        vm.stopBroadcast();

        // ---------------------------------------------------------
        // 5. Output Verification
        // ---------------------------------------------------------
        console.log("=== VEDA ARCTIC DEPLOYMENT COMPLETE ===");
        console.log("Lens (Frontend API):", address(lens));
        console.log("Teller (User Gate): ", address(teller));
        console.log("Vault (Holdings):   ", address(vault));
        console.log("Morpho Decoder:     ", address(morphoDecoder));
    }
}


--- FILE: script/EmergencyExit.s.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/core/AccountantWithRateProviders.sol";

contract EmergencyExit is Script {
    function run(address accountantAddr) external {
        vm.startBroadcast();
        // Fixed: Ensure we call the correct function on the Accountant
        AccountantWithRateProviders(accountantAddr).togglePause();
        console.log("SYSTEM PAUSED - EMERGENCY EXIT INITIATED");
        vm.stopBroadcast();
    }
}


--- FILE: test/VedaArctic.t.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/base/BoringVault.sol";
import "../src/core/ManagerWithMerkleVerification.sol";
import "../src/core/TellerWithMultiAssetSupport.sol";
import "../src/core/AccountantWithRateProviders.sol";
import "../src/hooks/WorldIDHook.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

contract VedaArcticTest is Test {
    BoringVault vault;
    AccountantWithRateProviders accountant;
    TellerWithMultiAssetSupport teller;
    WorldIDHook hook;
    MockERC20 usdc;

    address user = address(0xABCD);

    function setUp() public {
        usdc = new MockERC20("USDC", "USDC", 6);
        hook = new WorldIDHook();
        accountant = new AccountantWithRateProviders(address(this), address(usdc), address(hook), address(0x1));
        vault = new BoringVault(address(this), "Veda Yield", "vWY", usdc);
        teller = new TellerWithMultiAssetSupport(address(this), address(vault), address(accountant));

        vault.setManager(address(this));
        hook.setVerified(user, true);
        usdc.mint(user, 1000e6);
    }

    function test_UserDeposit_HappyPath() public {
        vm.startPrank(user);
        usdc.approve(address(teller), 1000e6);
        uint256 shares = teller.deposit(usdc, 1000e6);
        assertEq(shares, 1000e6);
        vm.stopPrank();
    }
}


--- FILE: test/VedaPointsSimulator.t.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/core/AccountantWithRateProviders.sol";
import "../src/core/TellerWithMultiAssetSupport.sol";
import "../src/hooks/WorldIDHook.sol";
import "../src/base/BoringVault.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

contract VedaPointsSimulator is Test {
    BoringVault vault;
    AccountantWithRateProviders accountant;
    TellerWithMultiAssetSupport teller;
    WorldIDHook hook;
    MockERC20 usdc;

    address human = address(0x1337);

    function setUp() public {
        usdc = new MockERC20("USDC", "USDC", 6);
        hook = new WorldIDHook();
        vault = new BoringVault(address(this), "Veda", "vWY", usdc);
        
        // Setup Core Protocol
        accountant = new AccountantWithRateProviders(
            address(this), 
            address(usdc), 
            address(hook), 
            address(0xFEED)
        );
        
        teller = new TellerWithMultiAssetSupport(
            address(this), 
            address(vault), 
            address(accountant)
        );

        // Wiring the Teller to the Accountant for point recording [cite: 15, 37, 41]
        accountant.setTeller(address(teller));
        vault.setManager(address(this));
        hook.setVerified(human, true);
    }

    function test_LoyaltyAndDAULogic() public {
        vm.startPrank(human);

        // Day 1: Initial Ping [cite: 44]
        teller.ping();
        uint256 pointsDay1 = accountant.points(human);
        assertEq(pointsDay1, 10 ether, "Should receive base points for first ping");

        // Day 15: Halfway through loyalty period
        vm.warp(block.timestamp + 15 days);
        teller.ping();
        uint256 pointsDay15 = accountant.points(human);
        assertEq(pointsDay15, 20 ether, "Should still have 1x multiplier");

        // Day 31: Loyalty Multiplier Kicks In (as defined in our optimized Accountant)
        vm.warp(block.timestamp + 16 days);
        teller.ping();
        uint256 pointsDay31 = accountant.points(human);
        
        // Accumulation logic: Day 1 (10) + Day 15 (10) + Day 31 (20 due to 2x boost)
        assertEq(pointsDay31, 40 ether, "Should receive 2x points after 30 days of loyalty");
        
        assertEq(accountant.lastInteraction(human), block.timestamp, "DAU timestamp should be current");
        vm.stopPrank();
    }
}


--- FILE: test/DeployVerification.t.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/core/AccountantWithRateProviders.sol";
import "../src/core/TellerWithMultiAssetSupport.sol";
import "../src/core/VedaArcticLens.sol";
import "../src/core/RevenueSplitter.sol";
import "../src/hooks/WorldIDHook.sol";
import "../src/base/BoringVault.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

contract DeployVerification is Test {
    BoringVault vault;
    AccountantWithRateProviders accountant;
    TellerWithMultiAssetSupport teller;
    WorldIDHook hook;
    RevenueSplitter splitter;
    VedaArcticLens lens;
    MockERC20 usdc;

    address mainOwner = address(0xAAAA);
    address testPartner = address(0xBBBB);
    address human = address(0xCCCC);

    function setUp() public {
        vm.startPrank(mainOwner);
        usdc = new MockERC20("USDC", "USDC", 6);
        hook = new WorldIDHook(); 
        splitter = new RevenueSplitter(mainOwner, testPartner);
        lens = new VedaArcticLens();

        accountant = new AccountantWithRateProviders(mainOwner, address(usdc), address(hook), address(splitter));
        vault = new BoringVault(payable(mainOwner), "Veda Arctic", "vUSDC", usdc);
        teller = new TellerWithMultiAssetSupport(mainOwner, address(vault), address(accountant));

        accountant.setTeller(address(teller));
        vault.setManager(mainOwner);
        hook.setVerified(human, true);
        vm.stopPrank();
    }

    function test_DeploymentWiring() public view {
        assertEq(accountant.teller(), address(teller));
        assertEq(address(teller.ACCOUNTANT()), address(accountant));
        assertEq(accountant.feeRecipient(), address(splitter));
    }

    function test_LensDataIntegrity() public {
        VedaArcticLens.Dashboard memory d = lens.getDashboard(human, address(vault), address(accountant), address(teller));
        assertEq(d.isVerified, true);
    }
}
